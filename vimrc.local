" check spelling
nmap <F2> :sign unplace *<CR>:setlocal spell! spelllang=en_us<CR>
nmap <F3> :sign unplace *<CR>:setlocal spell! spelllang=de_de<CR>
nmap <F4> :SpellCheck<CR>:Qtoggle<CR>

" silent grep wrapper
command! -nargs=* Grep
\ | execute ':Rooter'
\ | execute ':silent grep '.<q-args>
\ | execute ':redraw!'
\ | execute ':copen'

nnoremap <leader>g     :Grep<space>

" grep in buffers
command! -nargs=* BGrep
\ | execute ':Bgrep '.<q-args>
\ | execute ':copen'

nmap <leader>G :BGrep<space>

" undotree
nmap <leader>u :UndotreeToggle<CR>

" autoformat
nmap <leader>f :WsFix<CR> ":Autoformat<CR>

" close all buffers except current
nmap <C-q> :BufOnly<CR>

" focus undotree when toggled
let g:undotree_SetFocusWhenToggle = 1

" switch to project root
let g:rooter_manual_only = 1
let g:rooter_disable_map = 1
nmap <silent> <leader>, :Rooter<CR>

" goldenview window splitting
let g:goldenview__enable_default_mapping = 0

" camelcase word jumping
map <leader>w <Plug>CamelCaseMotion_w
map <leader>b <Plug>CamelCaseMotion_b
map <leader>e <Plug>CamelCaseMotion_e

" drag visuals
let g:Schlepp#allowSquishingLines = 1
let g:Schlepp#allowSquishingBlocks = 1
let g:Schlepp#reindent = 1
vmap <M-h>  <Plug>SchleppLeft
vmap <M-l>  <Plug>SchleppRight
vmap <M-j>  <Plug>SchleppDown
vmap <M-k>  <Plug>SchleppUp
nmap <M-j>  <S-v><Plug>SchleppDown
nmap <M-k>  <S-v><Plug>SchleppUp
vmap <M-d>  <Plug>SchleppDup
nmap <M-d>  <S-v><Plug>SchleppDup

" airline statusline
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:airline_theme='understated'

" disable backslash keybinding of indexed search
let g:indexed_search_show_index_mappings=0

" syntastic always populate location list + don't check on wq
let g:syntastic_check_on_open = 0
let g:syntastic_enable_signs  = 1
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_wq = 0

" syntastic use mri + rubocop for ruby code checking
let g:syntastic_ruby_checkers = ['mri', 'rubocop']

" styntastic java stuff
let g:syntastic_java_checkers = ['javac', 'checkstyle']
let g:syntastic_java_checkstyle_classpath = '/usr/share/java/checkstyle-5.7.jar'
let g:syntastic_java_checkstyle_conf = '/usr/share/checkstyle/sun_checks.xml'

" syntastic javascript
let g:syntastic_javascript_checkers=['jshint', 'flow']

" format java code
" let g:formatprg_args_expr_java = '"--mode=java --style=attach -pcH".(&expandtab ? "s".&shiftwidth : "t")'

" autoformat ruby
let g:formatters_ruby = ["rbeautify"]
let g:formatdef_rbeautify = '"-"'

" autoformat javascript
let g:formatters_javascript = ['jsbeautify']
let g:formatdef_jsbeautify = '"-"'

" rails policy navigation
command! -complete=file -nargs=1 Epolicy call s:EditPolicy(<f-args>)
function! s:EditPolicy(name)
    let name = a:name
    let len = strlen(name)
    let bang = stridx(name, "!", len - 1)
    if bang > 0
        let name = strpart(name, 0, len - 1)
    endif

    let fullname = "policies/" . name . "_policy.rb"
    let file = findfile(fullname, ".;")
    if file == ""
        if bang > 0
            execute "Rails generate pundit:policy " . name
            let file = findfile(fullname, ".;")
        else
            echo 'no such file'
            return
        endif
    endif

    execute "edit " . file
endfunction

" omnicomplete ruby
let g:rubycomplete_use_bundler = 1
let g:rubycomplete_load_gemfile = 1

" tex indents
let g:tex_indent_items=0
let g:LatexBox_custom_indent = '/usr/share/vim/vim74/indent/tex.vim'

" latexbox only show quickfix on error (don't autofocus)
let g:LatexBox_quickfix=4

" gitgutter settings
let g:gitgutter_realtime = 0
let g:gitgutter_eager = 0
let g:gitgutter_map_keys = 0

" easytag, automatic ctags, separate files for filetypes
let g:easytags_cmd = "/usr/bin/ctags-exuberant"
let g:easytags_dynamic_files = 1
let g:easytags_by_filetype = "~/.vim/vimtags/"
let g:easytags_async = 1
let g:easytags_ignored_filetypes = ''
let g:easytags_updatetime_min = 30000
let g:easytags_languages = {
            \   'zsh': {
            \     'cmd': g:easytags_cmd,
            \       'args': ['--fields=+l', '--c-kinds=+p', '--c++-kinds=+p'],
            \       'fileoutput_opt': '-f',
            \       'stdout_opt': '-f-',
            \       'recurse_flag': '-R'
            \   }
            \}

" use ag for the grep command
set grepprg=ag\ --nogroup\ --nocolor

" switch.vim
let g:switch_custom_definitions =
    \ [
    \   ['on', 'off'],
    \   ['==', '!='],
    \   ['_', '-'],
    \   [' < ', ' > '],
    \   ['<=', '>='],
    \   [' + ', ' - '],
    \   ['-=', '+='],
    \   ['and', 'or'],
    \   ['if', 'unless'],
    \   ['YES', 'NO'],
    \   ['yes', 'no'],
    \   ['first', 'last'],
    \   ['else', 'else if'],
    \   ['max', 'min'],
    \   ['px', '%', 'em'],
    \   ['left', 'right'],
    \   ['top', 'bottom'],
    \   ['margin', 'padding'],
    \   ['height', 'width'],
    \   ['absolute', 'relative'],
    \   ['horizontal', 'vertical'],
    \   ['show', 'hide'],
    \   ['visible', 'hidden'],
    \   ['add', 'remove'],
    \   ['up', 'down'],
    \   ['before', 'after'],
    \   ['slow', 'fast'],
    \   ['small', 'large'],
    \   ['even', 'odd'],
    \   ['inside', 'outside'],
    \   {'"\([^"]*\)"': '''\1''', '''\([^'']*\)''': '"\1"'},
    \   {
    \     '\<\(\l\)\(\l\+\(\u\l\+\)\+\)\>': "\\=tolower(substitute(submatch(0), '\\(\\l\\)\\(\\u\\)', '\\1_\\2', 'g'))",
    \     '\<\(\l\+\)\(_\l\+\)\+\>': "\\=substitute(submatch(0), '_\\(\\l\\)', '\\u\\1', 'g')",
    \   }
    \ ]

" default omnifunc
set omnifunc=syntaxcomplete#Complete

" filetype defs
autocmd vimrc Filetype ruby setlocal omnifunc=rubycomplete#Complete
autocmd vimrc Filetype ruby syn match Error "binding.pry"
autocmd vimrc FileType ruby nmap <leader><F9> :!rubocop -a % > /dev/null 2>&1<CR><CR>
autocmd vimrc FileType ruby setlocal tabstop=2
autocmd vimrc FileType ruby setlocal shiftwidth=2

autocmd vimrc FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd vimrc FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd vimrc FileType javascript setlocal omnifunc=tern#Complete
autocmd vimrc FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

autocmd vimrc Filetype tex setlocal omnifunc=LatexBox_Complete
autocmd vimrc FileType tex setlocal spell spelllang=en_us

" fzf:
nmap <silent> <leader>o :FZFTags<CR>
nmap <silent> <leader>i :FZFTagFile<CR>
nmap <silent> <leader>p :FZF<CR>
nmap <silent> <leader>; :FZFMru<CR>
nmap <silent> <leader>' :FZFBuffers<CR>
nmap <silent> <Leader>c :FZFColorscheme<CR>
nmap <silent> <Leader>l :FZFLines<CR>

" locate command integration
command! -nargs=1 Locate call fzf#run(
      \ {'source': 'locate <q-args>', 'sink': 'e', 'options': '-m'})

" choose colorscheme
command! FZFColorscheme call fzf#run({
\   'source':
\     map(split(globpath(&rtp, "colors/*.vim"), "\n"),
\         "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')"),
\   'sink':    'colo',
\   'options': '+m',
\   'left':    30
\ })<CR>
" jump to tags
command! -bar FZFTags if !empty(tagfiles()) | call fzf#run({
\   'source': "sed '/^\\!/d;s/\t.*//' " . join(tagfiles()) . ' | uniq',
\   'sink':   'tag',
\ }) | else | echo 'No tags' | endif

" jump to tags in current file
command! FZFTagFile if !empty(tagfiles()) | call fzf#run({
\   'source': "cat " . tagfiles()[0] . ' | grep "' . expand('%:@') . '"' . " | sed -e '/^\\!/d;s/\t.*//' ". ' |  uniq',
\   'sink':   'tag',
\   'options':  '+m',
\   'left':     60,
\ }) | else | echo 'No tags' | endif

" mru files
command! FZFMru call fzf#run({
            \'source': v:oldfiles,
            \'sink' : 'e ',
            \'options' : '-m',
            \})

" buffer switching
function! s:buflist()
  redir => ls
  silent ls
  redir END
  return split(ls, '\n')
endfunction

function! s:bufopen(e)
  execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

command! FZFBuffers call fzf#run({
\   'source':  reverse(<sid>buflist()),
\   'sink':    function('<sid>bufopen'),
\   'options': '+m',
\   'down':    len(<sid>buflist()) + 2
\ })<CR>

" select lines of open buffers
function! s:line_handler(l)
  let keys = split(a:l, ':\t')
  exec 'buf' keys[0]
  exec keys[1]
  normal! ^zz
endfunction

function! s:buffer_lines()
  let res = []
  for b in filter(range(1, bufnr('$')), 'buflisted(v:val)')
    call extend(res, map(getbufline(b,0,"$"), 'b . ":\t" . (v:key + 1) . ":\t" . v:val '))
  endfor
  return res
endfunction

command! FZFLines call fzf#run({
\   'source':  <sid>buffer_lines(),
\   'sink':    function('<sid>line_handler'),
\   'options': '--extended --nth=3..',
\   'down':    '60%'
\})

" fuzzy cmdline completion
cnoremap <silent> <c-l> <c-\>eGetCompletions()<cr>
"add an extra <cr> at the end of this line to automatically accept the fzf-selected completions.

function! Lister()
    call extend(g:FZF_Cmd_Completion_Pre_List,split(getcmdline(),'\(\\\zs\)\@<!\& '))
endfunction

function! CmdLineDirComplete(prefix, options, rawdir)
    let l:dirprefix = matchstr(a:rawdir,"^.*/")
    if isdirectory(expand(l:dirprefix))
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --select-1  --query=' .
                    \ a:rawdir[matchend(a:rawdir,"^.*/"):len(a:rawdir)],
                    \'dir': expand(l:dirprefix)
                    \}),
                    \'"' . escape(l:dirprefix, " ") . '" . escape(v:val, " ")'))
    else
        return join(a:prefix + map(fzf#run({
                    \'options': a:options . ' --query='. a:rawdir }),
                    \'escape(v:val, " ")'))
        "dropped --select-1 to speed things up on a long query
endfunction

function! GetCompletions()
    let g:FZF_Cmd_Completion_Pre_List = []
    let l:cmdline_list = split(getcmdline(), '\(\\\zs\)\@<!\& ', 1)
    let l:Prefix = l:cmdline_list[0:-2]
    execute "silent normal! :" . getcmdline() . "\<c-a>\<c-\>eLister()\<cr>\<c-c>"
    let l:FZF_Cmd_Completion_List = g:FZF_Cmd_Completion_Pre_List[len(l:Prefix):-1]
    unlet g:FZF_Cmd_Completion_Pre_List
    if len(l:Prefix) > 0 && l:Prefix[0] =~
                \ '^ed\=i\=t\=$\|^spl\=i\=t\=$\|^tabed\=i\=t\=$\|^arged\=i\=t\=$\|^vsp\=l\=i\=t\=$'
                "single-argument file commands
        return CmdLineDirComplete(l:Prefix, "",l:cmdline_list[-1])
    elseif len(l:Prefix) > 0 && l:Prefix[0] =~
                \ '^arg\=s\=$\|^ne\=x\=t\=$\|^sne\=x\=t\=$\|^argad\=d\=$'
                "multi-argument file commands
        return CmdLineDirComplete(l:Prefix, '--multi', l:cmdline_list[-1])
    else
        return join(l:Prefix + fzf#run({
                    \'source':l:FZF_Cmd_Completion_List,
                    \'options': '--select-1 --query='.shellescape(l:cmdline_list[-1])
                    \}))
    endif
endfunction

" NeoComplete

" Disable AutoComplPop.
let g:acp_enableAtStartup = 0

" Use smartcase.
let g:neocomplete#enable_smart_case = 1

" Use neocomplete.
let g:neocomplete#enable_insert_char_pre = 1
let g:neocomplete#enable_at_startup = 0
autocmd VimEnter * NeoCompleteEnable    " Workaround to make multiple-cursors fast

" Make multiple cursors fast with neocomplete
function! Multiple_cursors_before()
    exe 'NeoCompleteDisable'
endfunction
function! Multiple_cursors_after()
    exe 'NeoCompleteEnable'
endfunction

" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 2
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplete#auto_completion_start_length = 2
let g:neocomplete#manual_completion_start_length = 2

" neocomplete should not do anything with ctags
" just read the tagfiles...
let g:neocomplete#ctags_command = ""

" For snippet_complete marker.
" if has('conceal')
" 	set conceallevel=2 concealcursor=vin
" endif

" heavy: refresh always
let g:neocomplete#skip_auto_completion_time = '0.1'
let g:neocomplete#enable_refresh_always = 0
let g:neocomplete#enable_prefetch = 1

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'zsh' : $HOME.'/.zsh_history',
    \ 'sh' : $HOME.'/.zsh_history',
    \ 'ruby' : $HOME.'/.pry_history',
    \ 'scala' : $HOME.'/.scala_history',
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" <TAB>/<S-TAB>: completion next/prev
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
imap <expr><S-Tab>  pumvisible() ? "\<C-p>" :"\<S-TAB>"

" ctrl+shift+tab: force tab, even if completion menu visible
"imap <expr><C-@>  neocomplete#close_popup() . "<TAB>"

" trigger normal completion with ctrl+tab
"inoremap <expr><ESC>{  neocomplete#start_manual_complete() . "<c-p>"

" trigger omnicompletion with ctrl+space
inoremap <C-Space> <c-x><c-o><c-p>
imap <C-@> <C-Space>

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#close_popup()."<C-h>"
inoremap <expr><BS> neocomplete#close_popup()."<C-h>"
inoremap <expr><C-e>  neocomplete#cancel_popup()

" For cursor moving in insert mode
inoremap <expr><Left>  neocomplete#close_popup() . "\<Left>"
inoremap <expr><Right> neocomplete#close_popup() . "\<Right>"
inoremap <expr><Up>    neocomplete#close_popup() . "\<Up>"
inoremap <expr><Down>  neocomplete#close_popup() . "\<Down>"

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
if !exists('g:neocomplete#force_omni_input_patterns')
 let g:neocomplete#force_omni_input_patterns = {}
endif

let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
let g:neocomplete#force_omni_input_patterns.tex = '\cite\a\?{[^}]|\ref{[^}]'
let g:neocomplete#force_omni_input_patterns.ruby = '[^. *\t/]\.\w*\|\h\w*::'
let g:neocomplete#force_omni_input_patterns.java = '[^. \t/]\.\w*'
let g:neocomplete#force_omni_input_patterns.scala = '[^. \t/]\.\w*'
let g:neocomplete#force_omni_input_patterns.javascript = '[^. \t/]\.\w*'
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" let g:neocomplete#sources = {
"             \ '_' : ['file', 'member', 'omni', 'tag', 'buffer', 'syntax', 'dictionary']
"   \ }
let g:neocomplete#sources = {
            \ '_' : ['file', 'omni', 'buffer', 'syntax', 'dictionary']
  \ }
